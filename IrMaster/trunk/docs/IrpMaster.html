<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
  <meta content="text/html; charset=ISO-8859-1"
 http-equiv="Content-Type">
  <title>IrpMaster documentation</title>
</head>
<body>
<h1>IrpMaster documentation</h1>
<div style="text-align: center;">Bengt Martensson, <a
 href="mailto:barf@bengt-martensson.de">barf@bengt-martensson.de</a>,
2011-08-15<br>
</div>
<ul id="mozToc">
<!--mozToc h2 1 h3 2-->
  <li><a href="#mozTocId81212">Introduction</a>
    <ul>
      <li><a href="#mozTocId750586">Spelling,
pronunciation</a></li>
      <li><a href="#mozTocId649829">Synergies within
other projects </a></li>
      <li><a href="#mozTocId466098">Copyright and License</a></li>
    </ul>
  </li>
  <li><a href="#mozTocId47654">Main principles</a>
    <ul>
      <li><a href="#mozTocId531579">Design principles</a></li>
      <li><a href="#mozTocId920306">Repetitions</a></li>
    </ul>
  </li>
  <li><a href="#mozTocId47248">Command line usage</a>
    <ul>
      <li><a href="#mozTocId761509">Installing binaries </a></li>
      <li><a href="#mozTocId950115">Usage of the program
from the command line</a></li>
      <li><a href="#mozTocId543252">Iterating over input
parameter ranges</a></li>
      <li><a href="#mozTocId744763">Debugging
possibilities </a></li>
      <li><a href="#mozTocId719429">Third-party Java
archives (jars)</a></li>
    </ul>
  </li>
  <li><a href="#mozTocId130768">Extensions to, and
deviation from, IRP semantic and
syntax</a>
    <ul>
      <li><a href="#mozTocId503625">Parameter
Specifications</a></li>
      <li><a href="#mozTocId227580">The GeneralSpec</a></li>
      <li><a href="#mozTocId735529">Persistence of variables </a></li>
      <li><a href="#mozTocId171384">Comments and line
breaks</a></li>
      <li><a href="#mozTocId353483">Data types</a></li>
      <li><a href="#mozTocId872974">Multiple
definitions&nbsp; allowed</a></li>
      <li><a href="#mozTocId333818">Names</a></li>
      <li><a href="#mozTocId117419">GeneralSpecs, duty
cycle</a></li>
      <li><a href="#mozTocId765597">Namespaces</a></li>
      <li><a href="#mozTocId497724">Shift operators (not
currently implemented) </a></li>
      <li><a href="#mozTocId787549">Logical operators
(also not implemented) </a></li>
      <li><a href="#mozTocId780258">BitCount Function</a></li>
    </ul>
  </li>
  <li><a href="#mozTocId803373">Preprocessing and
inheritance</a></li>
  <li><a href="#mozTocId556865">The Configuration
file/IRP protocol database</a>
    <ul>
      <li><a href="#mozTocId886493">Syntax and semantics
of the IrpProtocols.ini file</a></li>
      <li><a href="#mozTocId240597">Requirements for an
IRP data base</a></li>
    </ul>
  </li>
  <li><a href="#mozTocId751876">Integration with DecodeIR</a></li>
  <li><a href="#mozTocId588407">The API</a>
    <ul>
      <li><a href="#mozTocId383267">Example of API usage </a></li>
    </ul>
  </li>
  <li><a href="#mozTocId242544">References</a></li>
</ul>
<h2><a class="mozTocH2" name="mozTocId81212"></a>Introduction</h2>
The "IRP notation" is a domain specific language for describing IR
protocols, i.e. ways of mapping a number of parameters to infrared
signals. It is a very powerful, slightly cryptic, way of describing
IR protocols. In early 2010, Graham Dixon (mathdon in the <a
 href="http://www.hifi-remote.com">JP1-Forum</a>) wrote a <a
 href="#Specification_of_IRP_Notation">specification</a>.
Up until now, there has not been a usable implementation of the
IRP-notation in the sense of a program that takes an IRP Protocol
together with parameter values, and produces an IR signal. (The <a
 href="#MakeHex">MakeHex</a> program operates on a previous, more
restricted version of the IRP notation. The <a href="#MakeLearned">MakeLearned</a>
program has severe restrictions, most importantly, its sources are not
available.) The present work is a Java program/library that is hoped to
fill that gap. It is written in Java 1.6, may or may not run with Java
1.5, but definitely not with earlier Java versions. It, optionally,
calls
the shared library DecodeIR on Windows, Linux, or Macintosh, but has no
other "impurities" in the sense of Java. It can be used as a command
line program, or it can
be used through its API. For parsing the IRP-Notation, the tool <a
 href="http://www.antlr.org">ANTLR</a> is used, generating the parser
automatically from the grammar.<br>
<br>
Presently, there is no graphical user interface (GUI). See <a
 href="#Design_principles">Design principles</a> for a background. It
may change in the future though :-) <br>
<br>
For understanding this document, and the program, a basic understanding
of IR protocol is assumed. However, the program
can be successfully used just by understanding that an "IRP protocol"
is a
"program" in a particular "domain specific language" for turning a
number of parameters into an IR signal, and the
present program is a compiler/interpreter of that language. Some parts
of this document requires more IRP knowledge, however.<br>
<br>
<h3><a class="mozTocH3" name="mozTocId750586"></a>Spelling,
pronunciation</h3>
The mandatory section...&nbsp; :-; Preferred spelling is "IrpMaster",
with
"I" and "M" capitalized (just as the Java class). Pronounce it any way
you like.<br>
<h3><a class="mozTocH3" name="mozTocId649829"></a>Synergies within
other projects<br>
</h3>
I hope&nbsp; that this program/library should be useful to other
projects involved in IR signals. It makes the vast knowledge of the JP1
project available to other programs. It can be used off-line, to
manually or automatically produce e.g. configuration files containing
rendered IR signal in some popular format, like the Pronto format. More
exciting is to implement a real time "IR engine", that can generate and
transmit IR signals in any of the known formats. <br>
<h3><a class="mozTocH3" name="mozTocId466098"></a>Copyright and License</h3>
The program, as well as this document, is copyright by myself. Of
course, it is
based upon the <a href="#Specification_of_IRP_Notation">IRP
documentation</a>, but is to be considered original work. The "database
file" IrpProtocols.ini is derived from <a href="#DecodeIR.html">DecodeIR.html</a>,
thus
I
do
not
claim
copyright.<br>
<br>
The program and its documentation are licensed under the <a
 href="http://www.gnu.org/licenses/gpl.html">GNU
General
Public
License
version 3</a>, making everyone free to use,
study, improve, etc., under certain conditions. <br>
<h2><a class="mozTocH2" name="mozTocId47654"></a>Main principles</h2>
<h3><a class="mozTocH3" name="mozTocId531579"></a><a
 name="Design_principles"></a>Design principles</h3>
It is my opinion that it is better to get the functionality and the
API right before you do a graphical user interface (GUI). It is much
easier and logical to put a GUI on top of a sane API, then to try to
extract API functionality from a program that was never designed
sanely but built around the GUI. (Look at WinZip for a good example of
the latter. Or almost any Windows program, commercial or freeware...) <br>
<br>
I have tried to follow the IRP document as closely as possible, in
particular with respect to the grammar and the syntax. The "Execution
mode" of Chapter 14. turned out to be less useful.<br>
<br>
Performance consideration were given minimal priorities. As it stands,
rendering a single IR signal typically takes less than 1 ms, so this
seems justified. Some debugging statements are covered
by functionally superfluous if-statements in order not to have to
evaluate arguments (<code>to String()</code> etc) not needed anyhow.<br>
<br>
Everything that is a "time" is internally represented as a double
precision number. Most output formats however, are in some integer
format. I here use the principle of sound numerics, do all computations
with "high precision" (i.e. double precision) as long as ever possible,
then transform to the lower precision form (i.e. integer formats) only
in the final step. <br>
<br>
All "integer quantities" like expressions, are done in Java long
format, 64 bits long, amounting to 63 bits plus sign. Already the <a
 href="#Example">metanec-example</a> would not work with Java int's.
The performance
penalty over using "int" is believed to be neglectable.<br>
<br>
I do not have the slightest interest in internationalization of the
project in its present form -- it does not contain a user friendly
interface anyhow.<br>
<h3><a class="mozTocH3" name="mozTocId920306"></a><a name="Repetitions"></a>Repetitions</h3>
Possibly the major difficulty in turning the <a
 href="#Specification_of_IRP_Notation">IRP Specification</a> into
programming code was how to make sense of the repetition concept. Most
treatises on IR signals (for example the Pronto format) considers an IR
signal as an introduction sequence (corresponding to pressing a button
on a remote control once), followed by a repeating signal,
corresponding to holding down a repeating button. Any, but not both of
these may be empty. In a few relatively rare cases, there is also an
ending sequence, send after a repeating button has been released.
Probably 99% of all IR signals fit into the intro/repetition scheme,
allowing ending sequence in addition should leave very few practically
used IR signals left. In "abstract" IRP notation, these are of the form
A,(B)+,C with A, B, and C being "bare irstreams". <br>
<br>
<br>
<br>
In contrast, the IRP notation in this concept reminds they syntax and
semantics of regular expressions: There may be any numbers, and they
can even be hierarchical. There certainly does not appear to be a
consensus on how this very,... general ... notation should be
practically thought&nbsp; of as a generator of IR signals. The
following, "finite-automaton interpretation" may make sense: An IRP
with several repetitions, say,&nbsp; A(B)+C(D)+E, can be thought of as
a remote control reacting on single and double presses. Pressing the
key and holding it down produces first A, then B's as long as the
button is pressed. An action such as shortly releasing the key and
immediately pressing it again then sends one C, and keeps sending D's
as long as button is kept pressed. When released, E is sent. Similarly,
hierarchical repetitions (repetitions containing other repetitions) may
be interpreted with some secondary "key" being pressed and/or released
while a "primary button" is being held down -- possibly like a
shift/meta/control modifier key on a keyboard or a sustain/wahwah-pedal
on a musical instrument? <br>
<br>
The present program does not implement hierarchical repetitions.
However, an unlimited number of non-hierarchical repetitions are
allowed, although not in the form if the class IrSignal -- it is
restricted to having three parts (intro, repeat, ending). Also, the
repetition pattern (...)* is rejected, because it does not make sense
as an IR signal.<br>
<br>
The command line interpreter contains an "interactive mode", entered by
the argument <code>--interactive</code>. This way the intrinsic finite
state machine (see above) inherent in an IRP with repetitions can be
interactively traversed, probably in the context of debugging. <br>
<br>
<h2><a class="mozTocH2" name="mozTocId47248"></a><br>
Command line usage</h2>
<h3><a class="mozTocH3" name="mozTocId761509"></a>Installing binaries<br>
</h3>
Unpack the zip library, preferably in an empty directory. Make sure
that you
have Java 6 installed and in your path. Open a terminal window,
x-term,&nbsp; dos-box, or what your preferred command line interpreter
is. cd to the installation directory. Test the program by typing <code>java
-jar
IrpMaster.jar</code>. The program should now respond with a long usage
message.<br>
<br>
Optionally, for DecodeIR support, copy DecodeIR.dll or libDecodeIR.so
in an architecture
dependent sub-directory like&nbsp; in RemoteMaster:&nbsp; <code>.\windows</code>
on Windows, <code>./Linux-amd64</code> and&nbsp; <code>./Linux-i386</code>
on 64- and 32-bit Linux respectively.<br>
&nbsp;<br>
<h3><a class="mozTocH3" name="mozTocId950115"></a>Usage of the program
from the command line</h3>
I will next describe how to invoke the program from the command line.
Elementary knowledge of command line usage is assumed.<br>
<br>
There is a lot of functionality crammed in the command line interface.
The usage message of the program gives an extremely brief summary:<br>
<br>
<pre>Usage: one of<br>        IrpMaster --help<br>        IrpMaster [--decodeir] [-c|--config &lt;configfilename&gt;] --version<br>        IrpMaster [OPTIONS] -n|--name &lt;protocolname&gt; [?]<br>        IrpMaster [OPTIONS] --dump &lt;dumpfilename&gt; [-n|--name &lt;protocolname&gt;]<br>        IrpMaster [OPTIONS] [-n|--name] &lt;protocolname&gt; [PARAMETERASSIGNMENT]<br>        IrpMaster [OPTIONS] [-i|--irp] &lt;IRP-Protocol&gt; [PARAMETERASSIGNMENT]<br><br>where OPTIONS=--stringtree &lt;filename&gt;,--dot &lt;dotfilename&gt;,--xmlprotocol &lt;xmlprotocolfilename&gt;,-c|--config &lt;configfile&gt;,-d|--debug &lt;debugcode&gt;|?,-s|--seed &lt;seed&gt;,-P|--pass &lt;intro|repeat|ending|all&gt;,--interactive,-o|--outfile &lt;outputfilename&gt;, -x|--xml, -I|--ict, -r|--raw, -p|--pronto, -#|--repetitions &lt;number_repetitions&gt;.<br><br>Any filename can be given as `-', meaning stdin or stdout.<br>PARAMETERASSIGNMENT is one or more expressions like `name=value' (without spaces!). One value without name defaults to `F`, two values defaults to `D` and `F`, three values defaults to `D`, `S`, and `F`, four values to `D`, `S`, `F', and `T`, in the order given.<br><br>All integer values are nonnegative and can be given in base 10, 16 (prefix `0x'), 8 (leading 0), or 2 (prefix `0b' or `%').<br><br>All parameter assignment, both with explicit name and without, can be given as intervals, like `0..255' or '0:255', causing the program to generate all signals within the interval. Also * can be used for parameter intervals, in which case min and max are taken from the parameterspecs in the (extended) IRP notation.<br><br><br></pre>
We will next explain this very brief description somewhat more
verbosely: The first version simply produces the help message, as per
above. The
second version will will print the versions of the program, and
optionally, the version of the configuration file and the DecodeIR
dynamic library (requires the<code> --version </code>argument to be
given last, since it is version command is executed immediately). The
third version prints the IRP string to the terminal. The forth version
dumps either the whole IRP data base, or just the protocol given as
argument, to the file name used as the argument to the <code>--dump</code>
option (use "-" for standard output). The last two versions, however,
is when it gets interesting: Using either an explicit IRP string with
the <code>-i&nbsp;</code> or <code>--irp</code>-option, or the name
of an IRP protocol (using the<code> -n</code> or <code>--name</code>
option),&nbsp;&nbsp; to be found in the data base/configuration file
specified by the<code> -c </code>or -<code>-config</code> option, that
protocol is used to render an IR signal or sequence using the supplied
parameters (more on that later). <br>
<br>
In the simplest and most general form, parameter assignments are made
on the command line in one argument of the type <code><span
 style="font-style: italic;">name</span>=<span
 style="font-style: italic;">value</span></code>. On both sides of the
"="-signs, there should not be any spaces. (More precisely, it is
required that all assignments are made within a single "argument" to
the program, which is determined by the command line interpreter. Thus
writing the arguments within single or double quotes, extra spaces can
be parsed.) After named parameters are given (possibly none), up to
four "standard" parameters can be given. These are, in order D, S, F,
and T (which per convention in the JP1 community stands for&nbsp;
"Device", "Subdevice", "Function" (also called OBC or command number),
and "Toggle"). If using -1 as the value, that parameter is considered
as not being assigned.&nbsp; One value without name defaults to `F',
two values defaults to `D' and `F', three values defaults to `D', `S',
and `F', and four to&nbsp; `D', `S', `F', and `T', in the order given.
For example, <br>
<br>
<pre>E=12 &nbsp;&nbsp; 34 &nbsp; -1 &nbsp; 56 &nbsp; 1</pre>
<br>
assigns the value 12 to E, the value 34 to
D, the value of 56 to F, and 1 to T, while S is not assigned anything
at all. Parameters can be given not only in decimal notation, but also
as hexadecimal (using prefix 0x) binary (using prefix 0b or %), or
octal (using prefix 0). <br>
<br>
If the command line cannot be parsed the usage message will be printed.
If you are unsure of exactly what is wrong, consider issuing&nbsp; "<code>-d
1</code>" (the debug option with argument 1) as the first argument on
the command line, which may produce more verbose error messages. <br>
<br>
Using the <code>-r</code> or <code>--raw</code> option, the output is
given in "raw form" (in JP1-Forum jargon, this is a sequence of
positive numbers (indicating "flashes", or on-times in micro seconds)
and negative numbers (indicating "gaps" or off-times, where the
absolute value indicates the duration in micro seconds. Carrier
frequency is specified separately). Alternatively, or additionally,
using the <code>-p</code> or <code>--pronto</code> option, output is
produced in the so-called Pronto format, see e.g. <a
 href="http://www.hifi-remote.com/wiki/index.php?title=Working_With_Pronto_Hex">this
document</a>. This format is popular in several IR using internet
communities, like <a href="http://www.promixis.com">Promixis</a>&nbsp;
(known for their (commercial) products Girder and NetRemote), as well
as <a href="www.eventghost.net">EventGhost</a>.&nbsp; Optionally,
these can be wrapped into an XML skeleton, offering an ideal platform
for translating to every other IR format this planet has encountered.
If desired, the output of the program is directed to a particular named
file using the <code>-o <span style="font-style: italic;">filename</span></code>
or <code>--output <span style="font-style: italic;">filename</span></code>
option. (There is also a possibility (using the <code>--ict</code> or <code>-I
</code>option)&nbsp; to generate output files in <a
 href="http://www.hifi-remote.com/wiki/index.php?title=IR_Scope_and_IR_Widget_User%27s_Guide">IRScope's
ict-format</a>, but I am not sure this was as wise design decision: it
may be a better idea to generate additional formats by post-processing
the XML file.)<br>
<br>
<h3><a class="mozTocH3" name="mozTocId543252"></a><a
 name="Iterating_over_input_parameter_ranges"></a>Iterating over input
parameter ranges</h3>
Either for generating configuration files for other programs, or for
testing, there is a very advanced feature for looping over input
parameter sets. For all of the parameters to a protocol, instead of a
single value, a set can be given. The program then computes all IR
signals/sequences belonging to the <a
 href="http://en.wikipedia.org/wiki/Cartesian_product">Cartesian product</a>
of the input parameter sets. There are four types of parameter
sets: <br>
<ol>
  <li>Of course, there is the singleton set, just consisting of one
value</li>
  <li>There is also a possibility to give some arbitrary values,
separated by commas. Actually, the commas even separate sets, in the
sense of the current paragraph.<br>
  </li>
  <li>An interval, optionally with a stride different from 1, can be
given, either as <code>min..max++increment</code> or <code>min:max++increment</code>,
or
alternatively,
simply
as
*, which will get the min and max values
from the parameter's parmeter specs. <br>
  </li>
  <li>Also, a set can be given as&nbsp; <code>a:b&lt;&lt;c</code>,
which has the following semantics: starting with <code>a</code>, this
is shifted to the left by <code>c</code> bits, until <code>b</code>
has been exceeded (reminding of the left-shift operator <code>&lt;&lt;</code>
found in languages such as C).&nbsp;</li>
  <li>Finally, a:b#c generates c pseudo random numbers between a and b
(inclusive). The "pseudo random" numbers are completely
deterministically determined from the seed, optionally given with the
"--seed" option. <br>
  </li>
</ol>
See the test file <a href="../test.shl">test.sh</a> for some examples.
Of course, using the command line, some of the involved characters,
most notably the *, has a meaning to the command line interpreter and
may need "escaping" by a backslash character, or double or single
quotes.<br>
<br>
<br>
There is also an option, denoted -<code>#</code> or <code>--repetitions
</code>taking an integer argument, that will compute that many "copies"
of the IR signal or sequence. This may be of interest for signals that
are non-constant (toggles being the simplest example) or for profiling
the program. <br>
<br>
<br>
<h3><a class="mozTocH3" name="mozTocId744763"></a>Debugging
possibilities<br>
</h3>
There are a number of different debug parameters available. Use -d or
--debug with "?" as argument for a listing: <br>
<pre>$ java -jar IrpMaster.jar&nbsp;&nbsp;&nbsp; --debug \?</pre>
<pre>Debug options: Main=1, Configfile=2, IrpParser=4, ASTParser=8, NameEngine=16, BitFields=32, Parameters=64, Expressions=128,<br>&nbsp;IrSignals=256, IrStreamItems=512, BitSpec=1024, DecodeIR=2048, IrStreams=4096, BitStream=8192, Evaluate=16384</pre>
For every debug option, there is an integer of the form 2^n associated
with it. Just add the desired numbers together and use as argument for
the <code>-d</code> or <samp>--debug</samp> command. There are also
commands for debugging the parsed version of the IRP: Notably the <code>--stringtree
&lt;filename&gt;
</code>option (produces a LISP-like parsed
representation of the so-called AST (abstract syntax tree)).<code>
--dot <span style="font-style: italic;">filename </span></code>produces
a
dot-file,
that
can
be translated by the open-source program dot
contained in the graphviz project, producing a nice picture (e.g. in
any common bitmap format) of the current IRP protocol, and<code>
--xmlprotocol <span style="font-style: italic;">filename</span></code>
producing an XML representation. It may be possible in the future to
use any of these representations to e.g., write a C code generator for
a particular protocol.<br>
<br>
Some of the classes contain their own main methods (for those not
familiar with the Java jargon: these can be called as programs on their
own) allowing for both debugging and pedagogical exploration, together
possibly with other possibilities. In particular, this goes for the
Expression class, One day I am going to document this...<br>
<br>
<pre> java -classpath IrpMaster.jar    IrpMaster/Expression -d  'a + b *c**#d'           {a=12,b=34,c=56,d=4}<br>(+ a (* b (** c (BITCOUNT d))))<br><br></pre>
<pre>1916</pre>
<h3><a class="mozTocH3" name="mozTocId719429"></a>Third-party Java
archives (jars)</h3>
For the DecodeIR-integration, IrpMaster requires a small support
package, DecodeIR.jar, which is distributed together with IrpMaster. It
consists of the compiled DecodeIRCaller,java from DecodeIr (full name
com/hifiremote/decodeir/DecodeIRCaller.class), and&nbsp;
com/hifiremote/LibraryLoader.class&nbsp; from RemoteMaster, which is
also GPL software. IrpMaster also requires the runtime libraries of the
parser generator&nbsp; <a href="http://www.antlr.org">ANTLR</a>, which
is also free softwarem but licensed under a <a
 href="http://www.antlr.org/license.html">BSD-License</a>. I
distribute the whole (binary) package <code>antlr-3.4-complete.jar</code>.
<br>
<pre><code></code><span style="font-family: monospace;"></span><code></code><br></pre>
<h2><a class="mozTocH2" name="mozTocId130768"></a>Extensions to, and
deviation from, IRP semantic and
syntax</h2>
<h3><a class="mozTocH3" name="mozTocId503625"></a>Parameter
Specifications</h3>
In the first, now obsolete, version of the IRP notation the parameters
of a protocol had to be declared with the allowed max- and min-value. I
have reinvented this, using the name parameter_spec. For example, the
well known NEC1 protocol, the Parameter Spec reads: <code>[D:0..255,S:0..255=255-D,F:0..255]</code>.
(D,
S,
and
F
have
the semantics of device, sub-device, and function or
command number.) This defines the three variables D, S, and F, having
the allowed domain the integers between 0 and 255. D and F must be
given, however, S has a default value that is used if the user does not
supply a value. The software requires that the values without default
values are actually given, and within the stated limits. If, and only
if, the parameter specs is incomplete, there may occur run-time errors
concerning not assigned values. It is the duty of the IRP author to
ensure that all variables that are referenced within the main&nbsp;
body of the IRP are defined either within the parameter specs, defined
with "definitions" (Chapter 10 of the specification), or assigned in
assignments before usage, otherwise a run-time error will occur
(technically an <code>UnassignedException </code>will be thrown). <br>
<br>
The preferred ordering of the parameters is: D, S (if present), F, T
(if present), then the rest in alphabetical order,<br>
<br>
The formal syntax is as follows, where the meaning of the '@' will be
explained in the <a href="#Persistency_of_variables">following section</a>:<br>
<br>
<pre>parameter_specs:</pre>
<pre>&nbsp;&nbsp;&nbsp; '[' parameter_spec (',' parameter_spec )* ']' | '['&nbsp; ']'</pre>
<pre>&nbsp;&nbsp;&nbsp; </pre>
<pre>parameter_spec:</pre>
<pre>&nbsp;&nbsp;&nbsp; name ':' number '.' '.' h=number ('=' i=bare_expression)?</pre>
<pre>&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp; name&nbsp; '@' ':' number '.' '.' number '=' bare_expression<br><br></pre>
<h3><a class="mozTocH3" name="mozTocId227580"></a>The GeneralSpec</h3>
For the implementation, I allow the four parts (three in the original
specification) to be given in any order, if at all, but I do not
disallow
multiple occurrences -- it is quite hard to implement cleanly and
simply
not
worth it. (For example, ANTLR does not implement exclusions. The only
language/grammar I know with that property is SGML, which is probably
one of the reasons why it was considered so difficult (in comparison
to XML) to write a complete parser.)
<pre><br></pre>
<h3><a class="mozTocH3" name="mozTocId735529"></a><a
 name="Persistency_of_variables"></a>Persistence of variables<br>
</h3>
Graham, in the specification and in following forum contributions,
appears to consider all variables in a IRP description as intrinsically
persistent: They do not need explicit initialization, if they are not,
they are initialized to an undefined, random value. This may be a
reasonable model for a particular physical remote control, however,
from a scientific standpoint it is less attractive. I have a way of
denoting a variable, typically a toggle of some sort, as persistent by
appending an "@" to its name in the parameter specs. An initial value
(with syntax as default value) is here mandatory. It is set to its
initial value by the constructor of the Protocol class. Calling the
renderIrSignal(...) function or such of the Protocol instance typically
updates the value (as given in an assignment, a 0-1 toggle goes like
T=1-T). As opposed to variables that has not been declared as
persistent, it (normally) retains its value between the invocations of
renderIrSignal(...).&nbsp; A toggle is typically declared as <code>[T@:0..1=0]
</code>in the parameter specs.<br>
<br>
<h3><a class="mozTocH3" name="mozTocId171384"></a>Comments and line
breaks</h3>
Comments in the C syntax (starting with /* and ended by */) are allowed
and ignored. Line breaks can be embedded within an IRP string by
"escaping" the line break by a backslash<br>
<br>
<h3><a class="mozTocH3" name="mozTocId353483"></a>Data types</h3>
The IRP documentation clearly states that the carrier frequency is a
real number, while everything else is integers. Unfortunately, users of
the IRP notation, for example in the&nbsp; DecodeIR.html-File, has
freely used decimal, non-integer numbers. I have implemented the
following convention: Everything that has a unit (second or Hz),
durations and frequency, are real numbers (in the code double
precision numbers). <br>
<br>
<h3><a class="mozTocH3" name="mozTocId872974"></a>Multiple
definitions&nbsp; allowed</h3>
It turned out that the <a href="#Preprocessing_inheritance">preprocessing/inheritance
concept</a> necessitated allowing several definition objects. These are
simply evaluated in the order they are encountered, possibly
overwriting previous content. <br>
<br>
<h3><a class="mozTocH3" name="mozTocId333818"></a>Names</h3>
Previous programs (makehex, makelearned) have only allowed one-letter
names. However, in DecodeIR.html there are some multiletter names. The
IRP documentation allows multi-letter names, using only capital
letters. I have, admittedly somewhat arbitrarily, extended it to the
C-name syntax: Letters (both upper and lower cases) and digits allowed,
starting with letter. Underscore "_" counts as letter. Case is
significant.<br>
<br>
Also there are a few predefined, read-only variables, mainly for
debugging, although a practical use is not excluded. To distinguish
from
the normal, and not to cause name collision, they start by a dollar
sign. Presently, these are:&nbsp; <code>$count</code> (numbers the
call to a <code>render*-()</code>-function, after the constructor has
been called), <code>$pass </code>(Requested pass in a <code>--pass</code>-argument,
(or
from
API
call),
not
to be confused with the following), <code>$state</code>
(current state (intro=0, repeat=1, ending=3,...) of parsing of an IRP),
<code>$final_state </code>(undefined until the final state has been
reached, then the number of the final state). For example, the OrtekMCE
example <code>{...}&lt;...&gt;([P=0][P=1][P=2],4,-1,D:5,P:2,F:6,C:4,-48m)+[...]</code>
could be written with <code>$state</code> as <code>(4,-1,D:5,$state:2,F:6,C:4,-48m)+
</code>(disregarding last frame). <br>
<h3><a class="mozTocH3" name="mozTocId117419"></a>GeneralSpecs, duty
cycle</h3>
Without any very good reason, I allow a duty cycle in percent to be
given within the GeneralSpec, for example as <code>{37k,123,msb,33%}</code>.
It
is
currently
not
used
for
anything,
but
preserved
through the
processing and can be retrieved using API-functions. If some, possibly
future, hardware needs it, it is there.<br>
<br>
<h3><a class="mozTocH3" name="mozTocId765597"></a>Namespaces</h3>
There is a difference in between the IRP documentation and the
implementation of the Makehex program, in that the former has one name
space for both <span style="font-style: italic;">assignments</span>
and <span style="font-style: italic;">definitions</span>, while the
latter has two different name spaces. IrpMaster has one name space, as
in the documentation. (This is implemented with the <span
 style="font-weight: bold;">NameEngine</span> class.)<br>
<h3><a class="mozTocH3" name="mozTocId497724"></a>Shift operators (not
currently implemented)<br>
</h3>
It has sometimes been suggested (see <a
 href="http://www.hifi-remote.com/forums/viewtopic.php?t=11850">this
thread</a>) to introduce the shift operators "&lt;&lt;" and
"&gt;&gt;"&nbsp; with syntax and semantics as in C. This far, I have
not
done so, but I estimate that it would be a very simple addition. (The
reader might like to have a look at my <a href="#Example">example</a>,
which possibly would have been more naturally expressed with left
shifts than with multiplication with powers of two.)<br>
<br>
<h3><a class="mozTocH3" name="mozTocId787549"></a>Logical operators
(also not implemented)<br>
</h3>
In particular in the light of <a
 href="http://www.hifi-remote.com/forums/viewtopic.php?t=13374&amp;start=17">current
discussion
on
the
F12
protocol</a>, in my opinion more useful would be
the logical operators &amp;&amp;, ||, and ?:, having their
short circuiting semantics, like in languages such as C, Perl,..., but
unless, e.g. Pascal. Recall, the expression A
&amp;&amp; B is evaluated as follows: First A is checked for being 0 or
not. If 0, then 0 is returned, without even evaluating B. If however, A
is nonzero,&nbsp; B is evaluated, possibly to a "funny"&nbsp; type and
is returned. The F12 protocol (cf. the latest version 2.43 of <a
 href="#DecodeIR.html">DecodeIR.html</a>) could then probably be
written like <code>&lt;...&gt;(introsequence, (H &amp;&amp;
repetitionsequence*))</code> or <code>&lt;...&gt;(H ? longsequence+ :
shortsequence)</code>.<br>
<br>
<h3><a class="mozTocH3" name="mozTocId780258"></a>BitCount Function</h3>
Generally, I think you should be very reluctant to add "nice features"
to something like IRP. However, in the applications in DecodeIR.html,
the phrase "number of ones", often modulo 2 ("parity"), occurs
frequently in the more complicated protocols. This is awkward and
error prone to implement using&nbsp; expressions, for example: <code>F:1
+
F:1:1
+
F:1:2
+
F:1:4
+ F:1:5 + F:1:6 + F:1:7</code> . Instead, I have
introduced the BitCount function, denoted by "#". Thus, odd parity of <code>F</code>
will be <code>#F%1</code>, even parity <code>1-#F%2</code>. It is
implemented by translating to the&nbsp; <a
 href="http://download.oracle.com/javase/6/docs/api/java/lang/Long.html#bitCount%28long%29">Java
Long.bitCount</a>-function.<br>
<br>
<br>
<h2><a class="mozTocH2" name="mozTocId803373"></a>Preprocessing and
inheritance</h2>
Reading through the protocols in <a>DecodeIR.html</a>,
the
reader is struck by the observation that there are a few general
abstract "families", and many concrete protocol are "special cases".
For example all the variants of the NEC* protocols, the
Kaseikyo-protocols,
or the rc6-families. Would it not be elegant, theoretically as well as
practically, to be able to express this, for example as a kind of
inheritance, or sub-classing?<br>
<br>
For a problem like this, it is easily suggested to invoke a general
purpose macro preprocessor, like the <a
 href="http://en.wikipedia.org/wiki/C_preprocessor">C preprocessor</a>
or <a href="http://en.wikipedia.org/wiki/M4_%28computer_language%29">m4</a>.
I
have
successfully
resisted
that
temptation, and am instead offering
the following solution: If the IRP notation does&nbsp; not start with
"{" (as they all have to do to confirm with the specification), the
string up until the first "{" is taken as an "ancestor protocol", that
has hopefully been defined at some other place in the configuration
file. Its name is replaced by its IRP string, with a possible parameter
spec removed -- parameter specs are not sensible to inherit. The
process is then repeated up until, currently, 5 times. <br>
<br>
The preprocessing takes place in the class IrpMaster, in its role as
data base manager for IRP protocols.<br>
<br>
<h4><a name="Example"></a><a name="Example_"></a>Example</h4>
(This shows excepts from a virtual configuration file, with <a>tentative
format
like
this</a>.)
Let
us define the "abstract" protocol "<code>metanec</code>" by<br>
<br>
<pre>[protocol]</pre>
<pre>name=metanec</pre>
<pre>irp={38.4k,564}&lt;1,-1|1,-3&gt;(16,-8,A:32,1,-78,(16,-4,1,-173)*) [A:0..4294967295]<br><br></pre>
having an unspecified 32 bit payload, to be subdivided by it "inherited
protocols". Now we can define, for example, the nec1 protocol as<br>
<br>
<pre>[protocol]<br>name=nec1<br>irp=metanec{A = D | 2**8*S | 2**16*F | 2**24*(~F:8)}[D:0..255,S:0..255=255-D,F:0..255]<br></pre>
As can be seen, this definition does nothing else than to stuff the
unstructured payload with D, S, and F, and to supply a corresponding
parameter spec.&nbsp;&nbsp; The IrpMaster class replaces "<code>metanec</code>"
by&nbsp;
<span style="font-family: monospace;">"</span><code>{38.4k,564}&lt;1,-1|1,-3&gt;(16,-8,A:32,1,-78,(16,-4,1,-173)*)</code>"
(note
that
the
parameter
spec
was stripped), resulting in an IRP string
corresponding to the familiar NEC1 protocol. Also, the "Apple protocol"
can now be formulated as <br>
<br>
<pre>[protocol]<br>name=Apple<br>irp=metanec{A=D | 2**8*S | 2**16*C:1 | 2**17*F | 2**24*PairID} \<br>{C=1-(#F+#PairID)%2,S=135} \<br>[D:0..255=238,F:0..127,PairID:0..255]</pre>
<br>
The design is not cast in iron, and I am open to suggestions for
improvements. For example, it seems reasonable that protocols that only
differ in carrier frequency should be possible to express in a concise
manner. <br>
<h2><a class="mozTocH2" name="mozTocId556865"></a><a
 name="The_Configuration_fileIRP_protocol"></a>The Configuration
file/IRP protocol database</h2>
There is presently not a "official" IRP database. <a href="#MakeHex">MakeHex
</a>comes with a number of protocol files with the ".irp"-extension,
but that is another, obsolete and much less powerful format. <a
 href="#MakeLearned">MakeLeaned</a> also comes with a number of
"irp-files", in the new format, but incomplete. The <a
 href="#DecodeIR.html">DecodeIR.html</a>-file presently comes closest:
it has a number (upper two-digit) of "IRPs", however, often not even
syntactically confirming to the <a
 href="#Specification_of_IRP_Notation">specification</a>, and often
with the description of the protocol at least partially in prose ("C
is the number of ..."), parseable only by humans, not by programs. <br>
<br>
Possibly as an intermediate solution, I invented the <a
 href="../data/IrpProtocols.ini">IrpProtocols.ini</a> file. This file
has a format similar to ini-files under Windows. For every protocol, it
contains name and an IRP-string, possibly also a documentation string.
The latter can, in principle, contain HTML elements, i.e. it can be an
HTML fragment. <br>
<br>
<h3><a class="mozTocH3" name="mozTocId886493"></a>Syntax and semantics
of the IrpProtocols.ini file</h3>
Every protocol is described in a section starting with the key <code>[protocol]</code>.
Then
there
are
a
few keywords describing different properties:<br>
<ul>
  <li>name The name of the protocol. This is folded to lowercase for
comparisons. <br>
  </li>
  <li>irp The IRP string representation. This may continue over several
lines if the line feeds are escaped by a backslash ("\"), i.e. having
the backspace as last character on the line.</li>
</ul>
Other keywords are allowed, but ignored. Then, optionally, there may be
a section [documentation], that, in principle, could contain e.g. an
HTML-fragment. The documentation section continues until the next <code>[protocol]</code>
is encountered.<br>
<br>
<h3><a class="mozTocH3" name="mozTocId240597"></a>Requirements for an
IRP data base</h3>
I have created the present <a href="../data/IrpProtocols.ini">IrpProtocols.ini
</a>by hand editing the <a href="#DecodeIR.html">DecodeIR.html</a>-file.
I
would
welcome
if
the community can settle for one endorsed format for
such a data base. It can be one file, or many files: One file per
protocol is easier for the developer, in particular if several
developers are using a version management system (with or without file
locking), but less convenient for the user.<br>
<br>
It would be highly desirable in the future to be able just to maintain
one file (or set of files). Some possibilities for this are:<br>
<br>
<ol>
  <li>Have one master file, for example in XML format, that after
preprocessing <span style="font-style: italic;">generates</span> both <a
 href="#DecodeIR.html">DecodeIR.html</a>, and a protocol description
file. There is also the possibility of having a program like IrpMaster
parsing the master file directly.</li>
  <li>Extend <code>protocol.ini </code>("belonging to RemoteMaster")
with the IRP information. Leaves the problem of duplicated
"documentation" between DecodeIR.html and protocols.ini.</li>
  <li>Formalizing the IRP-Strings within <a href="#DecodeIR.html">DecodeIR.html</a>,
e.g.
by
using
div
or span elements with class-attributes, (and
formatting with, for example, better CSS style sheets) so that the IRP
information can be unambiguously read out.<br>
  </li>
</ol>
<br>
<h2><a class="mozTocH2" name="mozTocId751876"></a><br>
Integration with DecodeIR</h2>
Optionally (when installed and selected with the <code>--decodeir</code>
option) the computed IR signal is sent to DecodeIR, to check DecodeIR's
opinion on the nature of the signal. This gives a magnificent
possibility
for automated tests, not only of the present program, but also of
DecodeIR. Note in particular that there are very advance possibilities
for testing not only a single signal, but for testing whole ranges of
signals, a list of signals, "random" inputs, equidistant inputs, or
inputs achieved by shifting, see the section on <a
 href="#Iterating_over_input_parameter_ranges">parameter iterating</a>.<br>
<br>
The shared library is sought first in architecture dependent
sub-directories, like in RemoteMaster, <code>.\windows</code> on
Windows, <code>./Linux-amd64</code> and&nbsp; <code>./Linux-i386</code>
on 64- and 32-bit Linux respectively,&nbsp; etc, then in system
libraries, for example given on the command line to the Java VM,
using&nbsp; the <code>-Djava.library.path=</code> option.<br>
<br>
There is some fairly hairy programming in <code>DecodeIR.java</code>
for identifying some different cases.<br>
<br>
The enclosed script test.sh runs under a Unix/Linux shell such as bash
or sh. It should also run within <a href="http://www.cygwin.com/">Cygwin</a>
on Windows. It does not run with the standard Windows command line
interpreter. Note that it might need some adjustment of file paths etc.<br>
<br>
Possibly because I did not find any more logical way to dispose it, the
current distribution contains a class (with main()-method) named
EvaluateLog that can be used to evaluate the output of the above
script. Use like<br>
<br>
<code>java -classpath IrpMaster.jar IrpMaster/EvaluateLog protocols.log</code><br>
<h2><a class="mozTocH2" name="mozTocId588407"></a>The API</h2>
The Java programmer can access the functionality through a number of
API functions. <br>
<br>
The class <code>IrpMaster</code> is the data base manager. The class
is immutable, constructed from a file name (or an InputStream), and can
deliver assorted pieces of information from the data base. Most
interesting is the <code>newProtocol()</code>-function that generates
a Protocol-object from parsing the IRP-string associated with the
requested protocol name. It contains a very elaborate <code>main()</code>-function
for
command
line
use
--&nbsp;
strictly speaking this is "the program" that
is described herein. Actually, that <code>main()</code>-function does
not
necessarily belong to the IrpMaster class, but could be located
somewhere else.<br>
<br>
Instances of the Protocol class are constructed (essentially) from a
String, containing the IRP representation to be parsed. Once
constructed (and IRP-String parsed), the Protocol instances can render
IrSignals and IrSequences for many different parameter values. This is
done with the render(...) and renderIrSignal(...) functions, producing
IrSequences and IrSignals respectively:<br>
<br>
An IrSequence is a sequence of pulse pairs. It does not know weather it
is supposed to repeat or not. In contrast, an IrSignal has one
introductory IrSequence, one repetition IrSequence (either, but not
both, of these can be empty), and an (in most cases empty) ending
IrSequence. <br>
<br>
<br>
<br>
The API is documented in standard Javadoc style, which can be installed
from the source package, just like any other Java package. For the
convenience of the reader, the javadoc API documentation is also
available <a href="http://harctoolbox.org/IrpMaster/javadoc/">here</a>,
at
my
own
website.<br>
<br>
A final note, this program is in its first stage, thus I may no promise
not to change the API in the future, or even to maintain backwards
compatibility.<br>
<br>
<h3><a class="mozTocH3" name="mozTocId383267"></a>Example of API usage<br>
</h3>
The task is to write a command line program, taking, in order,&nbsp;
the configuration file name, a protocol name, a device number and a
function/command/obc number, and send the corresponding IR signal to a <a
 href="http://www.globalcache.com/products/gc-100/models1/">Global
Cach&eacute; GC-100-06</a> networked IR-transmitter, having IP address
192.168.1.70, using its IR Port 1. For this, we use the
GlobalCach&eacute;
functionality of the&nbsp; <a href="http://harctoolbox.org/">Harctoolbox</a>,
which
is
also
GPL-software
written
by
myself. This task is solved with <a href="IRPMasterAPIExample.java">essentially
just
a few lines of code</a>.<br>
<br>
<br>
<h2><a class="mozTocH2" name="mozTocId242544"></a>References</h2>
<ol>
  <li><a name="Specification_of_IRP_Notation"></a><a
 href="http://www.hifi-remote.com/wiki/index.php?title=IRP_Notation">Specification
of
IRP
Notation</a>, Graham Dixon. Also in <a
 href="http://www.hifi-remote.com/forums/dload.php?action=file&amp;file_id=7926">PDF
version
for
download







    </a>. A very thorough specification.</li>
  <li><a href="http://www.hifi-remote.com/forums/viewtopic.php?t=11850">Discussion
thread
on
the
IRP
documentation</a><br>
  </li>
  <li><a name="DecodeIR.html"></a>DecodeIR.html. Contained within the
current distribution of <a
 href="http://www.hifi-remote.com/forums/dload.php?action=category&amp;cat_id=81">DecodeIR</a>.</li>
  <li><a name="MakeHex"></a>Makehex. <a
 href="http://www.hifi-remote.com/forums/dload.php?action=file&amp;file_id=8501">Source</a>,








    <a
 href="http://www.hifi-remote.com/forums/dload.php?action=file&amp;file_id=5209">binary</a>.
A
functional
predecessor
of
the
present
program.
Operates
on a predecessor
of the current version of the IRP. Written in C++, also available as
DLL (within the first link). <a
 href="http://www.hifi-remote.com/forums/dload.php?action=file&amp;file_id=9855">Java
translation</a> by myself.<br>
  </li>
  <li><a name="MakeLearned"></a>Makeleaned. <a
 href="http://www.hifi-remote.com/sony/MakeLearned_b1.zip">Binary only</a>,
source
unavailable.
GUI
only,
no
API.
Not
maintained
since 2005. Almost
certainly incomplete with respect to current IRP specification. <a
 href="http://www.hifi-remote.com/forums/viewtopic.php?t=5444">Discussion
thread
in
JP1-Forum</a>.<br>
  </li>
</ol>
</body>
</html>
